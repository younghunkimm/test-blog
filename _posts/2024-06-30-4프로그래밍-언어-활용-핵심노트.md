---
title: 정보처리기사 4과목 프로그래밍 언어 활용 핵심노트
categories: [정보처리기사]
tags: [정보처리기사, 자격증, 프로그래밍 언어 활용]
date: '2024-06-30 13:55:00 +0900'
mermaid: true
---

## 응집도와 결합도

* 모듈의 독립성을 판단하는 지표
* 응집도는 높을수록 좋고 결합도는 낮을수록 이상적이다.

### 응집도 (Cohesion)

> 모듈 내부의 기능적인 응집 정도를 나타낸다.

> 밑으로 갈수록 응집도가 강함
{: .prompt-tip}

1. <span style="color: orange; font-size: 150%">우</span>연적(Coincidental Cohesion)
   : 모듈 내부의 각 구성요소들이 연관이 없을 경우

2. <span style="color: orange; font-size: 150%">논</span>리적(Logical Cohesion)
   : 실제와 달리 논리적으로만 같은 그룹으로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우

3. <span style="color: orange; font-size: 150%">시</span>간적(Temporal Cohesion)
   : 연관된 기능이라기 보단 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우

4. <span style="color: orange; font-size: 150%">절</span>차적(Procedural Cohesion)
   : 모듈 안의 구성요소들이 서로 다른 기능을 하지만 그 기능을 순차적으로 수행할 경우

5. <span style="color: orange; font-size: 150%">교</span>환적(Communicational Cohesion)
   : 서로 다른 기능을 수행하지만 동일한 입력과 출력을 사용하는 활동들이 모여있을 경우

6. <span style="color: orange; font-size: 150%">순</span>차적(Sequential Cohesion)
   : 모듈 내의 한 활동으로부터 나온 출력값을 모듈 내의 다른 활동이 사용할 경우

7. <span style="color: orange; font-size: 150%">기</span>능적(Functional Cohesion)
   : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우


### 결합도 (Coupling)

> 모듈과 모듈간의 상호 결합 정도를 나타낸다.

> 밑으로 갈수록 결합도가 약함
{: .prompt-tip}

1. <span style="color: orange; font-size: 150%;">내</span>용 결합도(Content Coupling)
   : 하나의 모듈이 직접적으로 다른 모듈의 내용을 참조하는 경우

2. <span style="color: orange; font-size: 150%;">공</span>통 결합도(Common Coupling)
   : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역변수를 갱신하는 식으로 상호작용하는 경우

3. 외<span style="color: orange; font-size: 150%;">부</span> 결합도(External Coupling)
   : 어떤 모듈에서 반환한 값을 다른 모듈에서 참조해서 사용하는 경우

4. <span style="color: orange; font-size: 150%;">제</span>어 결합도(Control Coupling)
   : 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어신호를 이용하여 통신하는 경우

5. <span style="color: orange; font-size: 150%;">스</span>탬프 결합도(Stamp Coupling)
   : 모듈간의 인터페이스로 배열이나 오브젝트, 스트럭쳐등이 전달되는 경우

6. <span style="color: orange; font-size: 150%;">자</span>료 결합도(Data Coupling)
   : 모듈간의 인터페이스 전달되는 파라미터를 통해서만 모듈간의 상호 작용이 일어나는 경우

---

## OSI 7계층

> [외우는 Tip]\
> 아A 파P 서S 탈T 났N 다D 픽PHY
{: .prompt-tip}

> 하위계층

* **물리 계층 (<span style="color: orange; font-size: 150%">Phy</span>sical Layer)**
  * 전송에 필요한 두 장치 간의 실제 접속과 절단 등에 필요한 전송 매체의 기계적, 전기적, 기능적, 절차적 틍성에 대한 규칙 정의
  * 데이터 전송 단위: <span style="color: orange;">비트</span>
  * RS-232C, X.21 등

  > [Keyword]\
  > 물리적 전송 매체
  {: .prompt-tip}

* **데이터 링크 계층 (<span style="color: orange; font-size: 150%">D</span>ata Link Layer)**
  * 2개의 인접한 개방 시스템들 간의 <span style="color: orange;">신뢰성 있고 효율적인 정보 전송</span>을 할 수 있도록 한다.
  * <span style="color: orange;">링크 설정</span>, <span style="color: orange;">흐름제어</span>, <span style="color: orange;">동기화</span>, <span style="color: orange;">오류제어</span>, <span style="color: orange;">순서제어</span> 기능을 담당
  * 데이터 전송 단위: <span style="color: orange;">프레임</span>
  * HDLC, LAPB, PPP, LLC 등

  > [Keyword]\
  > 신뢰성 있는 링크
  {: .prompt-tip}

* **네트워크 계층 (<span style="color: orange; font-size: 150%">N</span>etwork Layer)**
  * 개방 시스템들 간의 <span style="color: orange;">네트워크 연결관리</span>(네트워크 연결을 설정, 유지, 해제), 데이터의 교환 및 중계 기능을 담당
  * 경로 설정(Routing), 트래픽 제어, 패킷정보 전송
  * 데이터 전송 단위: <span style="color: orange;">패킷</span>
  * X.25, <span style="color: orange;">IP</span> 등

  > [Keyword]\
  > 네트워크 연결관리
  {: .prompt-tip}

> 상위계층

* **전송 계층 (<span style="color: orange; font-size: 150%">T</span>ransport Layer)**
  * 종단 시스템(End to End) 간에 <span style="color: orange;">투명한 데이터 전송</span>이 가능하게 한다.
  * 전송 연결 설정, 데이터 전송, 연결해제 기능
  * 주소 설정, 다중화, <span style="color: orange;">오류제어</span>, <span style="color: orange;">흐름제어</span>
  * 데이터 전송 단위: <span style="color: orange;">세그먼트</span>
  * <span style="color: orange;">TCP</span>, <span style="color: orange;">UDP</span> 등

  > [Keyword]\
  > 데이터 전송(전달)
  {: .prompt-tip}

* **세션 계층 (<span style="color: orange; font-size: 150%">S</span>ession Layer)**
  * 송수신측 간의 관련성을 유지하고 <span style="color: orange;">대화 제어를 담당</span>
  * 대화 구성 및 동기제어, 데이터 교환 관리 기능
  * 체크점(=동기점): 오류가 있는 데이터의 회복을 위해 사용되는 것으로 소동기점과 대동기점이 있다.
  * 데이터 전송 단위: 메시지
  * RPC, NetBIOS 등

  > [Keyword]\
  > 대화 세션
  {: .prompt-tip}

* **표현 계층 (<span style="color: orange; font-size: 150%">P</span>resentation Layer)**
  * 응용 계층으로부터 받은 데이터를 세션 계층에 맞게, 세션 계층에서 받은 데이터는 응용계층에 맞게 <span style="color: orange;">형태를 변환</span>하는 기능
  * 코드 변환, 데이터 암호화, 데이터 압축, 구문검색, 정보형식(포맷) 변환, 문맥관리 기능
  * 데이터 전송 단위: 메시지
  * JPEG, MPEG 등

  > [Keyword]\
  > 형태 변환
  {: .prompt-tip}

* **응용 계층 (<span style="color: orange; font-size: 150%">A</span>pplication Layer)**
  * 사용자(응용 프로그램)이 <span style="color: orange;">OSI 환경에 접근</span> 할 수 있도록 서비스를 제공한다.
  * 정보 교환, 파일 전송, 전자사서함, 가상터미널 기능
  * 데이터 전송 단위: 메시지
  * HTTP, FTP, SMTP, POP3, IMAP, Telnet 등

  > [Keyword]\
  > 응용 프로그램
  {: .prompt-tip}

---

## TCP/IP

### TCP/IP 란?

* 인터넷에 연결된 서로 다른 기종의 컴퓨터 간에 데이터 송수신이 가능하도록 도와주는 표준 프로토콜

### TCP/IP의 4계층

|                 OSI                 |        TCP/IP        | 기능 및 주요 프로토콜                                                                        |
| :---------------------------------: | :------------------: | :------------------------------------------------------------------------------------------- |
| 응용 계층<br>표현 계층<br>세션 계층 |      응용 계층       | - 응용 프로그램 간의 데이터 송/수신 제공<br>- TELNET, FTP, SMTP, DNS, HTTP 등                |
|              전송 계층              |      전송 계층       | - 호스트들 간의 신뢰성 있는 통신 제공<br>- TCP, UDP                                          |
|            네트워크 계층            |     인터넷 계층      | - 데이터 전송을 위한 주소 지정, 경로 설정을 제공<br>- IP, ICMP, IGMP, ARP, PARP              |
|    데이터 링크 계층<br>물리 계층    | 네트워크 액세스 계층 | - 실제 데이터(프레임)을 송/수신하는 역할<br>- Ethernet, IEEE 802, HDLC, X.25, RS232C, ARQ 등 |

> <span style="color: orange;">ARP</span> (인터넷 계층)\
> TCP/IP 네트워크에서 IP주소(논리주소)를 MAC주소(물리주소)로 변환하는 프로토콜
>
> <span style="color: orange;">RARP</span> (인터넷 계층)\
> ARP 의 반대
>
> <span style="color: orange;">ICMP</span> (인터넷 계층)\
> IP의 동작 과정에서의 전송 오류가 발생하는 경우에 대비해 오류 정보를 전송하는 목적으로 사용하는 프로토콜
{: .prompt-tip}

### TCP (Transmission Control Protocol)

* OSI 7계층의 <span style="color: orange;">전송 계층</span>에 해당
* 신뢰성 있는 <span style="color: orange;">연결형 서비스</span>
* 3-Way HandShaking 과정을 통해 연결을 설정하고 4-way handshaking 을 통해 해제한다.
* 패킷의 다중화, 순서 제어, <span style="color: orange;">오류 제어</span>, <span style="color: orange;">흐름 제어</span> 기능
  
  > <span style="color: orange;">흐름 제어 기법</span>
  > * Stop and Wait: <span style="color: orange;">한 번에 프레임 1개만 전송</span>
  > * Sliding Window: 수신 측에서 제대로 수신한 바이트에 대한 확인 응답을 전송할 때마다 버퍼의 범위가 한꺼번에 이동
  {: .prompt-tip}
  
  > <span style="color: orange;">혼잡 제어 기법</span>
  > * Slow Start (느린 출발)
  > * Congestion Avoidance (혼잡 회피)
  > * Fast Retransmit (빠른 재전송)
  > * Fast Recovery (빠른 회복)
  {: .prompt-tip}
  
  > <span style="color: orange;">오류 제어 기법: ARQ (Automatic Repeat Request)</span>\
  > **오류나 분실된 패킷을 감지하고 재전송하는 기능**
  >
  > * Stop-and-wait ARQ (정지-대기 ARQ)
  > * Go-Back-N ARQ
  > * Selective-Repeat ARQ (선택적 재전송 ARQ)
  > * Adaptive ARQ (적응적 ARQ)
  {: .prompt-tip}

* <span style="color: orange;">스트림(Stream) 전송</span> 기능
* TCP 헤더의 크기는 <span style="color: orange;">최소 20Byte</span>, <span style="color: orange;">최대 40Byte</span>까지 확장 가능

### IP (Internet Protocol)

* OSI 7계층의 <span style="color: orange;">네트워크 계층</span>에 해당
* 데이터그램을 기반으로 하는 <span style="color: orange;">비연결형 서비스</span>
* 패킷의 분할/병합, <span style="color: orange;">주소 지정</span>, <span style="color: orange;">경로 선택</span> 기능
* 헤더의 길이는 <span style="color: orange;">최소 20Byte</span>에서 <span style="color: orange;">최대 60Byte</span>
* <span style="color: orange;">Best Effort 원칙</span>에 따른 전송 기능을 제공한다.

### UDP (User Datagram Protocol)

* OSI 7계층의 <span style="color: orange;">전송 계층</span>에 해당
* <span style="color: orange;">데이터 전송 전 연결 설정하지 않는 비연결형으로 신뢰성과 안정성이 낮다.</span>
* 신뢰성보다는 속도가 중요한 네트워크에 사용
* TCP보다 속도가 빠르고 실시간 전송에 유리
* TCP보다 단순한 헤더 구조로 오버헤드가 적다.
* 전송 시 순서가 없으므로 <span style="color: orange;">순서 제어, 흐름 제어가 없다. (빠름)</span>
* UDP 헤더 크기는 기본 <span style="color: orange;">8Byte 고정</span>

---

## IPv4 & IPv6

### IPv4

* <span style="color: orange;">32bit</span>
* <span style="color: orange;">10진수</span> **`127.0.0.1`**
* 멀티캐스트(Multicast), 유니캐스트(Unicast), <span style="color: orange;">브로드캐스트(Broadcast)</span>
* 대역대별로 클래스가 나뉜다.

| 클래스 | 범위                        | 설명             |
| :----: | :-------------------------- | :--------------- |
| classA | 0.0.0.0 ~ 127.255.255.255   | 국가, 대형통신망 |
| classB | 128.0.0.0 ~ 191.255.255.255 | 중대형 통신망    |
| classC | 192.0.0.0 ~ 223.255.255.255 | 소규모 통신망    |
| classD | 224.0.0.0 ~ 239.255.255.255 | 멀티캐스트용     |
| classE | 240.0.0.0 ~ 255.255.255.255 | 실험용           |
  
### IPv6

* <span style="color: orange;">128bit</span>
* 16비트씩 8부분을 <span style="color: orange;">16진수</span>로 표현 **`2dfc:0:0:0:0217:cbff:fe8c:0`**
* IPv4의 주소 부족 문제를 해결하기 위해 개발되었다.
* 멀티캐스트(Multicast), 유니캐스트(Unicast), <span style="color: orange;">애니캐스트(Anycast)</span>
* 패킷 크기를 확장할 수 있으므로 패킷 크기에 제한이 없다.
* <span style="color: orange;">확장 헤더</span>를 통해 네트워크 기능 확장이 용이하다.
* 인증성, 기밀성, 데이터 무결성의 지원으로 보안 문제를 해결할 수 있다.

---

## TCP Header

![TCP Header](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/e65454ae-7083-4ebc-af76-67da95042fa3 "TCP Header")

* **Source Port (16bit)**
  * 전송 포트
  * 세그먼트의 <span style="color: orange;">출발지</span>를 나타내는 포트번호가 담긴다.

* **Destination Port (16bit)**
  * 수신 포트
  * 세그먼트의 <span style="color: orange;">목적지</span>를 나타내는 포트번호가 담긴다.

* **Sequence Number (32bit)**
  * 순서 번호
  * <span style="color: orange;">전송하는 데이터의 순서를 의미</span>하며, 수신 측에서 Sequence Number로 순서를 파악해서 다시 올바른 순서로 재조립할 수 있다.

* **Acknowledge Number (32bit)**
  * 'ACK 번호' 라고도 한다.
  * <span style="color: orange;">다음에 수신될 것으로 예상되는 세그먼트의 번호를 의미</span>한다.

* **Header Length (4bit)**
  * 'HLEN' 라고도 한다.
  * 데이터가 시작되는 위치가 어디인지를 나타내서 이 값을 통해 데이터의 시작 위치를 알 수 있다.

* **Reserved**
  * <span style="color: orange;">미래를 위해 남겨놓는 필드</span>이다.

* **Flag Bits (6bit)**
  * 데이터를 관리하거나 제어하는 역할이다.
  * Flag Bits의 6가지 종류 (URG, ACK, PSH, RST, SYN, FIN)
    * **URG 플래그**
      * Urgent: 긴급한
      * <span style="color: orange;">이 포인터가 가리키는 긴급한 데이터는 제일 먼저 처리</span>한다.

    * **ACK 플래그**
      * <span style="color: orange;">필드에 값이 채워져 있음</span>을 알린다.

    * **PSH 플래그**
      * Push: 밀다
      * TCP 버퍼가 일정한 크기만큼 쌓여야 전송을 하는데 버퍼를 채우지 않고 바로 전송을 수행(Push)하는 플래그

    * **RST 플래그**
      * Reset: 초기화
      * 이미 TCP 연결이 되어 있을 때 이 연결을 강제로 해제하기 위해 사용한다.

    * **SYN 플래그**
      * Synchronize: 동기화
      * <span style="color: orange;">상대방과 연결을 생성할 때, 시퀀스 번호의 동기화를 맞추기 위해 사용</span>된다.

    * **FIN 플래그**
      * Finish: 끝
      * 연결 종료(전송할 데이터가 없음)를 의미한다.

* **Window Size (16bit)**
  * 미래를 위해 남겨놓는 필드

* **Checksum (16bit)**
  * <span style="color: orange;">데이터를 송신하는 중에 발생할 수 있는 오류를 검출</span>한다.

* **Urgent pointer (16bit)**
  * <span style="color: orange;">긴급 포인터를 의미</span>한다.
  * <span style="color: orange;">이 포인터가 가리키는 데이터는 긴급한 데이터로 처리되어 제일 먼저 처리</span>된다.

* **Option**
  * <span style="color: orange;">TCP의 기능을 확장할 때 사용하는 영역</span>이다.
  * 이 영역은 크기가 <span style="color: orange;">가변적</span>이다.

---

## IPv4 Header

![IPv4 Header](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/e1184383-dc17-490b-a326-75171f2e458f "IPv4 Header")

* **Version (4bit)**
  * IP 프로토콜의 version을 의미한다.

* **Header Length (4bit)**

  > IHL

  * 헤더의 길이를 의미한다.
  * IP 프로토콜의 헤더의 길이를 32비트 워드 단위로 표시한다.

* **Type of Service (8bit)**

  > DSCP + ECN

  * IP 데이터그램의 서비스를 의미한다.
  * FTP나 DNS, SMTP 같은 서비스의 유형을 알려준다.

* **Total Packet Length (16bit)**

  > Total length

  * IP 헤더 및 데이터를 포함한 IP 패킷 전체 길이를 바이트 단위로 길이를 표시
  * 최대값은 <span style="color: orange;">65,535 = 2^16 - 1</span>

* **Identification (16bit)**
  * 패킷이 전송될 때 구분을 하기 위해서 붙은 식별 번호를 뜻한다.
  * IP 데이터그램이 단편화되었을 때 단편화 된 데이터그램이 원래 어떤 데이터그램에 속해 있는지를 알 수 있다.

* **Flags (3bit)**
  * 프래그먼트 패킷의 상태나 생성 여부를 결정하는 플래그
  * IP 데이터그램이 단편화됐는지 안됐는지를 나타낸다.

* **Fragment Offset (13bit)**
  * 조각나기 전 원래의 데이터그램의 바이트 범위를 나타낸다.

* **Time to Live (8bit)**
  * IP패킷의 수명을 나타낸다.
  * TTL 이라고도 부른다.

* **Protocol (8bit)**
  * 어느 상위계층 프로토콜이 데이터 내에 포함되었는가를 보여준다.

* **Header Checksum (16bit)**
  * <span style="color: orange;">Header 필드의 오류를 검출</span>한다.

  > Data Checksum 은 제공하지 않는다.
  {: .prompt-tip}

* **Source Address (32bit)**
  * 송신 측의 IP 주소를 나타낸다.

* **Destination Address (32bit)**
  * 목적지 IP 주소를 나타낸다.

* **Options**
  * 선택사항 옵션
  * 선택사항에 따라 헤더의 크기가 달라진다.

## UDP Header

![UDP Header](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/7d274a28-ba55-42d8-9bbc-bd142bf850bc "UDP Header")

---

## 서브넷 마스크

> IP Subnet-zero 를 적용했다는 것은 '192.168.1.0' 도 사용하겠다는 의미
>
> 각 서브넷에서 호스트 ip가 전부 0인 주소(네트워크 자체 주소)와 전부 1인 주소(broadcast IP 주소)는 다른 용도로 이미 예약되어있다.

### 예제1

> 200.1.1.0/24 네트워크를 FLSM 방식을 이용하여 10개의 Subnet으로 나누고 ip subnet-zero를 적용했다.\
> 이때 서브네팅된 네트워크 중 10번째 네트워크의 broadcast IP 주소는?

* **좌측부터 24비트가 Net ID, 8비트는 호스트 ID**

* **필요 개수**
  * 10개의 Subnet → 2^4 (4비트 사용)

* **서브넷 마스크**
  * 255.255.255.0
  * 200.1.1.`1111`0000 → 255.255.255.240

* **네트워크 대역**
  1. 200.1.1.`0000`0000 → 200.1.1.0 ~ 15
  2. 200.1.1.`0001`0000 → 200.1.1.16 ~ 31
  3. 200.1.1.`0010`0000 → 200.1.1.32 ~ 47
  4. ...
  5. ...
  6. ...
  7. ...
  8. 200.1.1.`0111`0000 → 200.1.1.112 ~ 127
  9. 200.1.1.`1000`0000 → 200.1.1.128 ~ 143
  10. <span style="color: orange;">200.1.1.`1001`0000 → 200.1.1.144 ~ 159</span>
  11. 200.1.1.`1010`0000 → 200.1.1.160 ~ 175

* **정답: 200.1.1.159**

### 예제2

> 192.168.1.0/24 네트워크를 FLSM 방식을 이용하여 4개의 Subnet으로 나누고 IP Subnet-zero를 적용했다.\
> 이때 서브네팅된 네트워크 중 4번째 네트워크의 4번째 사용가능한 IP는?

* **좌측부터 24비트가 Net ID, 8비트는 호스트 ID**

* **필요 개수**
  * 4개의 Subnet → 2^2 (2비트 사용)

* **네트워크 대역**
  1. 192.168.1.`00`000000 → 0
  2. 192.168.1.`01`000000 → 64
  3. 192.168.1.`10`000000 → 128
  4. <span style="color: orange;">192.168.1.`11`000000 → 192</span>

* **설명**
  : <span style="color: orange;">192.168.1.192 (네트워크 자체 주소)</span>  
  193, 194, 195, `196 (4번째)`

* **정답: 192.168.1.196**

---

## 세그먼트 테이블

> 논리 주소(2, 176) 에 대한 물리 주소는?

| 세그먼트 번호 |                시작 주소                | 길이(바이트) |
| :-----------: | :-------------------------------------: | :----------: |
|       0       |                   670                   |     248      |
|       1       |                  1752                   |     422      |
|   <u>2</u>    | <span style="color: orange;">222</span> |     198      |
|       3       |                   996                   |     604      |

* 논리 주소 = (세그먼트 번호, 변위값)
* 물리 주소 = 세그먼트 시작주소 + 변위값
  : `222` + `176` = `398`

---

## 네트워크 관련 장비

* **허브**
  * 한 사무실이나 가까운 거리의 컴퓨터들을 연결하는 장치로, 각 회선을 통합적으로 관리하며, 신호 증폭 기능을 하는 리피터 역할도 포함함

* **리피터**
  * 물리계층의 장비로, 전송되는 신호가 왜곡 되거나 약해질 경우 원래의 신호 형태로 재생함

* **브리지**
  * 데이터 링크 계층의 장비로 LAN과 LAN을 연결하거나 LAN 안에서 컴퓨터 그룹을 연결함

* **라우터**
  * 네트워크 계층의 장비로 LAN과 LAN의 연결 및 경로 선택, 서로 다른 LAN이나 LAN과 WAN을 연결함

* **게이트웨이**
  * 전 계층의 프로토콜 구조가 전혀 다른 네트워크의 연결을 수행함

* **스위치**
  * 브리지와 같이 LAN과 LAN을 연결하여 훨씬 더 큰 LAN을 만드는 장치  

---

## 라우팅 프로토콜

* **RIP**
  * 최단 경로 탐색에는 <span style="color: orange;">Bellman-Ford 알고리즘</span>을 사용하는 <span style="color: orange;">거리 벡터 라우팅 프로토콜</span>
  * 최적의 경로를 산출하기 위한 정보로 <span style="color: orange;">홉(거리 값)만을 고려</span>하므로, RIP을 선택한 경로가 최적의 경로가 아닌 경우가 많이 발생할 수 있다.
  * RIP은 OSPF와 함께 <span style="color: orange;">IGP(내부 게이트웨이 프로토콜)</span>에 해당한다.
  * <span style="color: orange;">소규모 네트워크 환경</span>에 적합하다.
  * <span style="color: orange;">최대 홉 카운트를 15홉 이하</span>로 한정하고 있다.
  * <span style="color: orange;">자율 시스템(AS)를 사용</span>한다.

* **IGRP**
  * RIP의 단점을 보완하기 위해 만들어 개발된 것으로, 네트워크 상태를 고려하여 라우팅하며, 중규모 네트워크에 적합함

* **OSPF**
  * 대규모 네트워크에서 많이 사용되는 라우팅 프로토콜로, 라우팅 정보에 변화가 생길 경우 변화된 정보만 네트워크 내의 모든 라우터에 알리며, RIP에 비해 홉수에 제한이 없음. 자신을 기준으로 한 다익스트라 알고리즘 기반으로 최단 경로를 찾는 라우팅 (Link-State) 프로토콜

* **BGP**
  * 자율 시스템(AS) 간의 라우팅 프로토콜로, 도달 가능성 정보를 교환하도록 설계된 표준화된 외부 게이트웨이 프로토콜의 하나. 대형 사업자(ISP)

> **자율 시스템 (AS: Autonomous System)**\
> \- 하나의 기관 내부를 나타내는 것으로 라우터들과 통신기기들의 집합이다. 예) 하나의 학내망
>
> **IGP (Interior Gateway Protocol, 내부 게이트웨이 프로토콜)**\
> \- 학내망 내부에서 라우팅하는 것. 즉, 하나의 AS 내에서의 라우팅에 사용되는 프로토콜
>
> **EGP (Exterior Gateway Protocol, 외부 게이트웨이 프로토콜)**\
> \- 학내망과 다른 학내망의 라우팅에 사용. 즉, AS 간의 라우팅에 사용되는 프로토콜
{: .prompt-tip}

---

## 운영체제

> 사용자와 하드웨어 간의 인터페이스 역할을 한다.

| 사용자 |
| 응용 프로그램 |
| 유틸리티 |
| <span style="color: orange;">운영체제</span> |
| 사용자 |

### 운영체제의 계층 구조

| 하드웨어 |
| CPU 관리 |
| 기억장치 관리 |
| 프로세스 관리 |
| 주변장치 관리 |
| 파일 시스템 관리 |
| 사용자 프로세스 |

### 운영체제의 목적

* 처리 능력(Throughput) 향상
  : 일정 시간 내에 시스템이 처리하는 일의 양

* 사용 가능도(Availability) 향상
  : 작업 의뢰 시간부터 처리 완료까지 걸린 시간

* 신뢰도(Reliability) 향상
  :  

* 반환 시간(Turn Around Time) 단축
  :  

### 운영체제의 기능에 따라 분류

* 제어 프로그램 (Control Program)
  * 감시 프로그램 (Supervisor Program)
    : 각종 프로그램의 실행과 시스템 전체의 작동 상태를 감시/감독한다.

  * 직접 제어 프로그램 (Job Control Program)
    : 다른 업무로의 이행을 자동으로 수행하기 위한 준비나 그 처리에 대한 완료를 담당한다.

  * 자료 관리 프로그램 (Data Management Program)
    : 주기억장치(ROM/RAM)와 보조기억장치(HDD/SSD) 사이에서 자료 전송, 파일의 조작 및 처리, 입출력 자료와 프로그램 간의 논리적 연결 등 파일과 데이터를 표준적인 방법으로 처리할 수 있도록 관리하는 시스팀

* 처리 프로그램 (Processing Program)
  * 언어 번역 프로그램 (Language Translate Program)
    : 원시프로그램(어셈블리어/고급언어)을 기계어 형태의 목적 프로그램으로 번역 (어셈블러, 컴파일러, 인터프리터)

  * 서비스 프로그램 (Service Program)
    : 사용자의 편리를 위해 시스템 제공자가 미리 작성하여 사용자에게 제공하는 것. 사용빈도가 높다.

  * 문제 프로그램 (Problem Program)
    : 문제해결을 위한 프로그램

### Windows 운영체제

* 마이크로소프트사가 개발한 운영체제
* GUI 사용
* 선점형 멀티태스킹 (Preemptive Multi-Tasking)
  : OS가 각 작업의 CPU 사용 시간을 제어한다.

* PnP (Plug and Play)
  : 환경을 자동으로 구성해준다.

* OLE (Object Linking and Embedding)
  : 작성중인 문서에 자유롭게 연결 및 삽입이 가능하다.

* 255자의 긴 파일명
* Single-User 시스템
  : 하나의 컴퓨터를 한 사람만 쓸 수 있다.

### UNIX 운영체제

* 주로 <span style="color: orange;">서버용 컴퓨터</span>에서 사용된다.
* time sharing system 을 위해 설계된 <span style="color: orange;">대화식 운영체제</span>
* 개방형 시스템이다.
* C언어로 작성되어 <span style="color: orange;">이식성이 높고, 장치간 호환성이 높다.</span>
* 크기가 작고, 이해하기 쉽다.
* <span style="color: orange;">Multi user, Multi tasking 모두 지원</span>한다.
* <span style="color: orange;">트리 구조</span>의 파일시스템
* 하나 이상의 작업에 대하여 <span style="color: orange;">백그라운드에서 수행</span>이 가능하다.

### Unix 시스템의 구성

| 사용자 |
| 유틸리티 |
| <span style="color: orange;">쉘</span> |
| <span style="color: orange;">커널</span> |
| 하드웨어 |

### 커널 (Kernel)

* 유닉스의 가장 핵심적인 부분이다.
* <span style="color: orange;">주기억장치</span>(main memory)에 적재된다.
* <span style="color: orange;">프로그램과 하드웨어</span>간의 인터페이스 역할을 한다.
* 하드웨어를 캡슐화한다.
* 프로세스 관리, 기억장치 관리 등을 담당한다.

### 쉘 (Shell)

* 사용자의 명령어를 인식한다.
* 프로그램을 <span style="color: orange;">호출</span>한다.
* <span style="color: orange;">명령을 수행</span>한다.
* <span style="color: orange;">시스템과 사용자</span>간의 인터페이스 역할을 한다.
* <span style="color: orange;">파이프라인</span> 기능을 제공한다.

### UNIX 명령어

* `ls`: 디렉토리나 파일목록 출력
* `fork`: 새로운 프로세스를 생성
* `cat`: 파일 내용 출력
* `chmod`: 파일이나 디렉토리에 대한 접근권한 변경

### 환경 변수 출력 명령어

* `printenv`
* `env`
* `setenv`

---

## 스레드 (Thread)

* 프로세스 병행성 증대를 위한 매커니즘
* 시스템의 여러 자원을 할당받아 실행하는 프로그램 단위
* 하나의 프로세스에 하나의 스레드가 존재하면 단일 스레드, 하나 이상의 스레드가 존재하면 다중 스레드라고 한다.
* 프로세스의 일부 특성을 가지므로 경량(Light Weight) 프로세스 라고도 한다.

### 스레드의 장점

* 하드웨어의 성능을 향상시킬 수 있다.
* 응용 프로그램의 처리율을 향상시킬 수 있다.
* 응용 프로그램의 응답 시간을 감소시킬 수 있다.
* 프로세스 간의 통신 속도가 향상된다.

### 사용자 수준의 스레드

* 생성할 때마다 프로세스 단위로 생성을 하기 때문에, 프로세스 겸 스레드라고 볼 수 있다.
* 이러한 특징 때문에 커널 스레드와 다르게 멀티 스레드 방식으로 동작하기 어렵다.

### 커널 수준의 스레드

### 사용자 수준과 커널 수준 비교

| 사용자 수준의 스레드                             | 커널 수준의 스레드                                 |
| :----------------------------------------------- | :------------------------------------------------- |
| 커널 개입이 작다.                                | 커널 개입이 크다.                                  |
| Run Time System이 필요하다.                      | 커널이 직접 한다.                                  |
| 속도가 빠르다.                                   | 속도가 느리다.                                     |
| 문맥 교환이 적다.                                | 문맥 교환이 많다.                                  |
| 독자적 알고리즘이 필요하다.                      | 독자적 알고리즘이 필요 없다.                       |
| 대형 시스템에 적당하다.                          | 대형 시스템에 부적당하다.                          |
| 구현이 어렵다.                                   | 구현이 쉽다.                                       |
| 커널을 스스로 호출하지 못한다.                   | 커널을 스스로 호출한다.                            |
| CPU 사용을 해제하지 못하면<br>시스템이 중단된다. | CPU 사용을 해제하지 못하면<br>운영체제가 지원한다. |

---

## 기억장치 배치전략

> 10K 크기의 프로그램 실행 시 각각 어느 부분에 할당되어야 하는지 영역 번호로 쓰시오.

| 영역 번호 | 메모리 크기 |   사용 여부   |
| :-------: | :---------: | :-----------: |
|    NO1    |     5K      |     FREE      |
|    NO2    |     14K     |     FREE      |
|  ~~NO3~~  |   ~~10K~~   | <u>IN USE</u> |
|    NO4    |     12K     |     FREE      |
|    NO5    |     16K     |     FREE      |

* 최초 적합 (First Fit)
  : 가능한 영역 중에서 첫 번째 분할 영역에 배치시키는 방법 `NO2`
* 최적 적합 (Best Fit)
  : 가능한 영역 중에서 단편화를 가장 작게 남기는 분할 영역에 배치하는 방법 `NO4`
* 최악 적합 (Worst Fit)
  : 가능한 영역 중에서 단편화를 가장 많이 남기는 분할 영역에 배치하는 방법 `NO5`

---

## 상호배제 기법

* 데커의 알고리즘 (Dekker Algorithm)
  * 프로세스가 두개일때 상호 배제를 보장하는 최초의 알고리즘
  * flag와 turn 변수를 사용하여 조정

* 램퍼드 알고리즘 (Lamport Algorithm)
  * 프로세스 n개의 상호 배제 문제를 해결한 알고리즘
  * 프로세스에게 고유한 번호를 부여하고, 번호를 기준으로 우선순위를 정하여 우선순위가 높은 프로세스가 먼저 임계구역에 진입하도록 구현

* 피터슨 알고리즘 (Peterson Algorithm)
  * 프로세스가 두개일때 상호 배제를 보장
  * 데커의 알고리즘과 유사하지만 상대방에게 진입 기회를 양보한다는 차이가 있고, 더 간단하게 구현된다.

* 세마포어 (Semaphore)
  ```plaintext
  P(S) : while S <= 0 do skip;
  S := S - 1;
  V(S) : S := S + 1;
  ```

  * 공유된 자원의 데이터 혹은 임계영역 등에 따라 Process 혹은 Thread가 접근하는 것을 막아줌 (동기화 대상이 하나 이상)

---

## 프로세스 스케쥴링

* CPU를 사용하려고 하는 프로세스들 사이의 우선순위를 관리하는 작업
* 서비스시간: 프로세스가 결과를 산출하기까지 걸리는 시간
* 대기시간: 프로세스가 CPU에 할당되기 전까지 큐에서 대기하는 시간

### 선점형 스케쥴링

* 하나의 프로세스가 CPU를 차지하고 있을 때 우선순위가 높은 다른 프로세스가 현재 프로세스를 중단시키고 CPU 차지 가능
  * 라운드로빈
  * SRT (Shortest Remaining Time First)
  * MLQ (다단계 큐)
  * MLFQ (다단계 피드백 큐)

### 비선점형 스케쥴링

* 하나의 프로세스가 CPU를 차지하고 있으면 작업 종료 후 CPU 반환까지 다른 프로세스가 선점 불가능
  * Priority (우선순위)
  * Deadline (기한부)
  * FCFS (First Come First Served)
    * 준비상태 큐에 도착한 순서에 따라 차례로 CPU를 할당하는 기법
    * 가장 간단한 알고리즘
  
  * SJF (Shortest Job First)
    * 가장 적은 평균 대기 시간을 제공하는 최적 알고리즘이다.

  * HRN (Highest Response-ratio Next)
    * 실행시간이 긴 프로세스에 불리한 SJF을 보완하기 위해 대기시간 및 서비스 시간을 이용
    * 우선순위를 계산하여가장 높은 것부터 낮은 순으로 우선순위가 부여된다.

    > 우선순위값 = (대기시간 + 서비스시간) / 서비스시간
    {: .prompt-tip}

    | 작업  | 대기시간 | 서비스(실행)시간 | 우선순위 |
    | :---: | :------: | :--------------: | :------: |
    |   A   |    5     |        20        |   1.25   |
    |   B   |    40    |        20        |    3     |
    |   C   |    15    |        45        | 1.333... |
    |   D   |    10    |        2         |    11    |

    > 우선순위: D → B → C → A

---

## 디스크 스케쥴링

### 디스크 스케쥴링이란?

* 데이터 액세스를 위해 디스크 헤드의 이동 경로를 결정하는 방법

### 디스크 스케쥴링의 목적

* 처리량의 최대화
* 응답 시간의 최소화
* 응답 시간 편차의 최소화

### 디스크 스케쥴링 기법

* **FCFS (First Come First Service) = FIFO**
  * 대기 큐에 먼저 들어온 트랙에 대한 요청을 먼저 처리하는 기법
  * 구현이 쉽지만 Arm이 많이 움직여서 Seek Time이 증가
  * FCFS 기법 적용 예

    > \<현재 헤드의 위치가 50에 있고, 요청 대기열에는 아래와 같은 순서로 들어 있다고 가정>

    | 100, 180, 40, 120, 0, 130, 70, 80, 150, 200 |

    * 이동 순서: 50 → `+50` 100 → `+80` 180 → `+140` 40 → `+80` 120 → `+120` 0 → `+130` 130 → `+60` 70 → `+10` 80 → `+70` 150 → `+50` 200
    * 헤드의 이동 거리: 790

* **SSTF (Shortest Seek Time First)**
  * 탐색 거리가 가장 짧은 트랙에 대한 요청을 먼저 처리하는 기법
  * 가운데 트랙이랑 안/바깥쪽 트랙이랑 응답시간 편차가 크다.
  * 너무 바깥쪽에 멀리 떨어져있으면 Starvation이 발생할 수도 있음.
  * SSTF 기법 적용 예

    > \<현재 헤드의 위치가 50에 있고, 트랙 0번 방향으로 이동하며, 요청 대기열에는 아래와 같은 순서로 들어 있다고 가정>

    | 100, 180, 40, 120, 0, 130, 70, 80, 150, 200 |

    * 이동 순서: 50 → `+10` 40 → `+30` 70 → `+10` 80 → `+20` 100 → `+20` 120 → `+10` 130 → `+20` 150 → `+30` 180 → `+20` 200 → `+200` 0
    * 설명: 50에서 가장 가까운 40, 40에서 가장 가까운 70, 70에서 가장 가까운 80 ... 반복
    * 헤드의 이동 거리: 370

* **SCAN**
  * 현재 진행중인 방향으로 가장 짧은 탐색 거리에 있는 요청을 먼저 처리하는 기법
  * 끝까지 이동한 후 역방향으로
  * Starvation은 발생하지 않으나 Wait Time이 뒤죽박죽임.
  * SCAN 기법 적용 예

    > \<현재 헤드의 위치가 50에 있고, 트랙 0번 방향으로 이동하며, 요청 대기열에는 아래와 같은 순서로 들어 있다고 가정>

    | 100, 180, 40, 120, 0, 130, 70, 80, 150, 200 |

    * 이동 순서: 50 → `+10` 40 → `+40` 0 → `+70` 70 → `+10` 80 → `+20` 100 → `+20` 120 → `+10` 130 → `+20` 150 → `+30` 180 → `+20` 200
    * 헤드의 이동 거리: 250

* **C-SCAN (Circular SCAN)**
  * 항상 바깥쪽에서 안쪽으로 움직이면서 가장 짧은 탐색 거리를 갖는 요청을 처리하는 기법
  * 끝까지 이동한 후 다시 바깥쪽의 끝으로 이동한 후 안쪽으로 처리
  * C-SCAN 기법 적용 예

    > \<현재 헤드의 위치가 50에 있고, 트랙 0번 방향으로 이동하며, 요청 대기열에는 아래와 같은 순서로 들어 있다고 가정>

    | 100, 180, 40, 120, 0, 130, 70, 80, 150, 200 |

    * 이동 순서: 50 → `+10` 40 → `+40` 0 → `+200` 200 → `+20` 180 → `+30` 150 → `+20` 130 → `+10` 120 → `+20` 100 → `+20` 80 → `+10` 70
    * 헤드의 이동 거리: 380

* **N-step SCAN**
  * SCAN 기법을 기초로 하여 어떤 방향의 진행이 시작될 당시에 대기 중이던 요청에 대해서만 서비스하고 진행 도중 도착한 요청들은 반대 방향 진행 때 처리하는 기법
  * SSTF나 SCAN 기법보다 응답 시간의 편차가 적음

* **LOOK / C-Lookup**
  * 기본적으로 양쪽 끝을 왕복하는데, 움직이고 있는 방향 쪽에 더이상 요청이 없으면 끝까지 가는게 아니라 그 시점에서 방향을 틀어버리는 것. 예측을 위한 계산이 별도로 필요하다.

---

## 페이지 교체 알고리즘

> 페이징 기법으로 메모리를 관리하는 운영체제에서 필요한 페이지가 주기억장치에 적재되지 않았을 시(페이지 부재) 어떤 페이지 프레임을 선택하여 교체할 것인지 결정하는 방법

### 페이지 교체 알고리즘의 종류

* `OPT (Optimal)`: 앞으로 가장 오랫동안 사용되지 않을 페이지 교체

  > ![OPT](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/5ec6f7e6-b64e-4975-baa0-0205d34abf37 "OPT")
  > 
  > <span style="color: orange;">9번의 페이지 결함 발생</span>

* `FIFO (First In First Out)`: 가장 먼저 들어온 페이지를 교체

  > ![FIFO](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/0f58ef1d-174f-4479-8f6c-5314716da3bb "FIFO")
  > 
  > <span style="color: orange;">15번의 페이지 결함 발생</span>

* `LRU (Least Recently Used)`: 가장 오랫동안 사용되지 않은 페이지 교체

  > ![LRU](https://github.com/younghunkimm/younghunkimm.github.io/assets/91935220/fe612499-4c5c-4ae3-8288-18a06a1805be "LRU")
  > 
  > <span style="color: orange;">9번의 페이지 결함 발생</span>

* `LFU (Least Frequently Used)`: 참조 횟수가 가장 작은 페이지 교체
* `MFU (Most Frequently Used)`: 참조 횟수가 가장 많은 페이지 교체
* `NUR (Not Used Recently)`: 최근에 사용하지 않은 페이지 교체

---

## 교착상태 (Dead Lock)

> 상호 배제에 의해 나타나는 문제점으로 둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며 무한정 기다리는 현상

### 교착상태 발생의 필요 충분 조건

* 상호 배제(Mutual Exclusion)
  : 한 번에 한 개의 프로세스만이 공유 자원을 사용할 수 있어야 함

* 점유와 대기(Hold and Wait)
  : 최소한 하나의 자원을 점유하고 있으면서 다른 프로세스에 할당돼 사용되고 있는 자원을 추가로 점유하기 위해 대기하는 프로세스가 있어야 함

* 비선점(Non-preemption)
  : 다른 프로세스에 할당된 자원은 사용이 끝날 때까지 강제로 빼앗을 수 없어야 함

* 환형 대기(Circular Wait)
  : 공유 자원과 공유 자원을 사용하기 위해 대기하는 프로세스들이 원형으로 구성돼 있어 자신에게 할당된 자원을 점유하면서 앞이나 뒤에 있는 프로세스의 자원을 요구해야 함

### 교착상태 해결 방법

* **Prevention (예방)**
  * 교착상태가 발생하지 않도록 사전에 시스템을 제어하는 방법으로 교착상태 발생의 네가지 조건 중에 어느 하나를 제거함으로써 수행
  * 상호 배제 부정
    : 한 번에 여러 개의 프로세스가 공유 자원을 사용할 수 있도록 함

  * 점유 및 대기 부정
    : 프로세스가 실행되기 전에 필요한 모든 자원을 할당해 프로세스 대기를 없애거나 자원이 점유되지 않은 상태에서만 자원을 요구

  * 비선점 부정
    : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납하고 요구한 자원을 사용하기 위해 기다리게 함

  * 환형 대기 부정
    : 자원을 선형 순서로 분류해 고유 번호를 할당하고 각 프로세스는 현재 점유한 자원의 고유 번호보다 앞이나 뒤 어느 한쪽 방향으로만 자원을 요구하도록 하는 것

* **Avoidance (회피)**
  * 교착상태가 발생할 가능성을 배제하지 않고 교착상태가 발생하면 적절히 피해나가는 방법으로 주로 <span style="color: orange;">은행원 알고리즘(Banker's Algorithm)</span>이 사용된다.

* **Detection (탐지)**
  * 시스템에 교착 상태가 발생했는지 점검해 교착 상태에 있는 프로세스와 자원을 발견하는 것으로 <span style="color: orange;">자원 할당 그래프</span> 등을 사용한다.

* **Recovery (복구)**
  * 교착 상태를 일으킨 <span style="color: orange;">프로세스를 종료</span>하거나 교착 상태의 프로세스에 할당된 <span style="color: orange;">자원을 선점</span>해 프로세스나 자원을 회복하는 것

---

## IEEE 802

* `.3`: ❗️❗️<span style="color: orange;">CSMA/CD</span> 방식의 매체접근 제어 계층 규약
* `.4`: ❗️<span style="color: orange;">토큰 버스(Token Bus)</span> 방식 규약
* `.5`: ❗️<span style="color: orange;">토큰 링(Token Ring)</span> 방식 규약
* `.11`: CSMA/CA (무선 랜)

---

## 배치 프로그램 (Batch Program)

### 배치 프로그램이란?

* 배치 프로그램이나 사용자와의 상호 작용 없이 여러 작업들을 미리 정해진 일련의 순서에 따라 일괄적으로 처리하는 것을 의미한다.

### 배치 프로그램이 갖추어야 하는 필수 요소

* 대용량 데이터
* 자동화
* 견고성
* 안정성/신뢰성
* 성능

---

## C언어

### 비트 연산자

| 연산자 |     의미      |                  설명                   |
| :----: | :-----------: | :-------------------------------------: |
|   &    |      and      |         모든 비트가 1일 때만 1          |
|   ^    |      xor      | 모든 비트가 같으면 0, 하나라도 다르면 1 |
|   \|   |      or       |    모든 비트 중 한 비트라도 1이면 1     |
|   ~    |      not      |    각 비트의 부정, 0이면 1, 1이면 0     |
|  \<\<  |  왼쪽 시프트  |          비트를 왼쪽으로 이동           |
|  \>\>  | 오른쪽 시프트 |         비트를 오른쪽으로 이동          |

> 예제1) 3 & 2

| 3 | = | 0 | 0 | 1 | 1 |   |     |
| 2 | = | 0 | 0 | 1 | 0 |   |     |
| & | = | 0 | 0 | 1 | 0 | = | `2` |

> 예제2) 4 \| 2

| 4  | = | 0 | 1 | 0 | 0 |   |     |
| 2  | = | 0 | 0 | 1 | 0 |   |     |
| \| | = | 0 | 1 | 1 | 0 | = | `6` |

> 예제3) 5 \<\< 1

| 5     | = | 0 | 1 | 0 | 1 |   |     |
| \<\< 1 | = | 1 | 0 | 1 | 0 | = | `10` |

### 연산자 우선순위

|     분류      |                               연산자                                | 결합규칙 |
| :-----------: | :-----------------------------------------------------------------: | :------: |
|  단항 연산자  | `! (논리not)` `~ (비트not)` `++ (증가)` `-- (감소)` `sizeof (기타)` |  `<--`   |
|  산술 연산자  |                `* (곱셈)` `/ (나눗셈)` `% (나머지)`                 |  `-->`   |
|               |                        `+ (덧셈)` `- (뺄셈)`                        |  `-->`   |
| 시프트 연산자 |                `<< (왼쪽시프트)` `>> (오른쪽시프트)`                |  `-->`   |
|  관계 연산자  |                          `<` `<=` `>=` `>`                          |  `-->`   |
|               |                              `==` `!=`                              |  `-->`   |
|  비트 연산자  |                            `& (비트and)`                            |  `-->`   |
|               |                            `^ (비트xor)`                            |  `-->`   |
|               |                            `⎮ (비트or)`                             |  `-->`   |
|  논리 연산자  |                           `&& (논리and)`                            |  `-->`   |
|               |                            `⎮⎮ (논리or)`                            |  `-->`   |
|  조건 연산자  |                               `?` `:`                               |  `-->`   |
|  대입 연산자  |              `=` `+=` `-=` `*=` `/=` `%=` `<<=` `>>=`               |  `<--`   |
|  순서 연산자  |                                 `,`                                 |  `-->`   |

---

## 파이썬

### 데이터 타입

* **시퀀스 데이터 타입**
  * 리스트: 순서 ⭕️, 가변 `[1, 2, 3]`
  * 튜플: 순서 ⭕️, 불변 `(1, 2, 3)`

* **세트 데이터 타입**
  * 세트: 순서 ❌, 중복 ❌ `{1, 2, 3}`

* **맵 데이터 타입**
  * 딕셔너리: 순서 ❌, key-value 쌍 `{'a': 1, 'b': 2, 'c': 3}`

### 배열

* `[:]`: 처음부터 끝까지
* `[start:]`: (start) 오프셋부터 끝까지
* `[:end]`: 처음부터 (end - 1) 오프셋까지
* `[start:end]`: (start) 오프셋부터 (end - 1) 오프셋까지
* `[start:end:stop]`: step만큼 문자를 건너 뛰면서 위와 동일

---

## JAVA

### 데이터 타입

* **정수 데이터 타입**
  * `byte`: 1 Byte
  * `Short`: 2 Byte
  * `int`: 4 Byte
  * `long`: 8 Byte

* **실수 데이터 타입**
  * `float`: 4 Byte
  * `double`: 8 Byte
  
### 빌드 도구

* Ant
* Maven
* Gradle

---

## 언어별 예제문제

### C언어 문제

> 예제1) 실행 결과

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    int a = 5, b = 3, c = 12;
    int t1, t2, t3;
    t1 = a && b; // 1
    t2 = a || b; // 1
    t3 = !c; // 0
    printf("%d", t1, t2, t3); // 1 + 1 + 0
    return 0;
}

// 정답: 2
```

> 예제2) 실행 결과

```c
#include <stdio.h>
int main(int arge, char *argv[]) {
    int n1 = 1, n2 = 2, n3 = 3;
    int r1, r2, r3;

    r1 = (n2 <= 2) || (n3 > 3); // 1
    r2 = !n3; // 0
    r3 = (n1 > 1) && (n2 < 3) // 0

    printf("%d", r3 - r2 + r1);
    return 0
}

// 정답: 1
```

> 예제3) a[0] 의 주소값이 10일 경우 실행 결과 (단, int 형의 크기는 4Byte로 가정)

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    int a[] = {14, 22, 30, 38};
    printf("%u, ", &a[2]); // 10 + (2 * sizeof(int)) = 18
    printf("%u", a); // a[0] 의 주소값
    return 0;
}

// 배열은 자료형이 같은 변수를 메모리에 연속으로 할당한다.

// 정답: 18, 10
```

> 예제4) 실행 결과

```c
#include <stdio.h>
int main(void) {
    int n = 4;
    int* pt = NULL;
    pt = &n;

    printf("%d", &n + *pt - *&pt + n);
    return 0;   
}

// 8
```

* `&n` : 변수 n의 주소값
* `*pt` : 포인터 `pt`가 가리키고 있는 주소에 저장된 값 = 변수 `n`
* `*&pt` : *(포인터 `pt`의 주소 값) = 포인터 `pt`의 주소가 가리키고 있는 주소에 저장된 값 = 변수 `n`의 주소

> 예제5) 실행 결과

```c
#include <stdio.h>
int main(int argc, char *argv[]) {
    int a = 4;
    int b = 7;
    int c = a | b;

    printf("%d", c);
    return 0;
}

// a: 0 0 0 0 0 1 0 0
// b: 0 0 0 0 0 1 1 1
// c: 0 0 0 0 0 1 1 1 (둘 중 하나라도 1이라면 1)

// 정답: 7
```

> 예제6) 실행 결과

```c
#include <stdio.h>
int main (int argc, char *argv[]) {
    char a;
    a = 'A' + 1;
    printf("%d", a);
    return 0;
}

// 'A'는 10진수로 65

// 정답: 66
```

> 예제7) 실행 결과

```c
#include <stdio.h>
int main (int argc, char *argv[]) {
    int a[2][2] = { {11, 22}, {44, 55} };
    int i, sum = 0;
    int *p;
    p = a[0];
    for (i = 1; i < 4; i++)
        sum += *(p + i);
    printf("%d", sum);
    return 0
}

// sum += *(a[0] + 1) → a[1] = 22
// sum += *(a[0] + 2) → a[2] = 44
// sum += *(a[0] + 3) → a[3] = 55

// 정답: 121
```

> 예제8) 실행 결과

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]) {
    int arr[2][3] = {1, 2, 3, 4, 5, 6}
    int (*p)[3] = NULL;
    p = arr; // p = arr[0]의 주소
    printf("%d" , *(p[0] + 1) + *(p[1] + 2)); // 2 + 6 = 8
    printf("%d", *(*(p + 1) + 0) + *(*(p + 1) + 1)); // 4 + 5 = 9
    return 0
}

// 정답: 8, 9
```

* arr 배열의 그림

  |       |    0     |    1     |    2     |
  | :---: | :------: | :------: | :------: |
  |   0   | 1 [0][0] | 2 [0][1] | 3 [0][2] |
  |   1   | 4 [1][0] | 5 [1][1] | 6 [0][2] |

* <span style="color: orange;">*(p[0] + 1) + *(p[1] + 2)</span>
  * `p[0] + 1` 은 `[0][1]` 과 같다 >> `2`
  * `p[1] + 2` 는 `[1][2]` 와 같다 >> `6`

* <span style="color: orange;">\*(\*(p + 1) + 0) + \*(\*(p + 1) + 1)</span>
  * `*(*(p + 1) + 0)` 은 `[1][0]` 과 같다 >> `4`
  * `*(*(p + 1) + 1)` 은 `[1][1]` 과 같다 >> `5`

> 예제9) 실행 결과

```c
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char *argv[]) {
    char str1[20] = "KOREA";
    char str2[20] = "LOVE";
    char* p1 = NULL;
    char* p2 = NULL;
    p1 = str1;
    p2 = str2;
    str1[1] = p2[2]; // KOREA의 O가 V로 변경 → "KVREA"
    str2[3] = p1[4]; // LOVE의 E가 A로 변경 → "LOVA"
    strcat(str1, str2); // str1 → "KVREALOVA"
    printf("%c", *(p1 + 2)); // *(p1 + 2) == str1[2] → "R"
    return 0;
}

// 정답: R
```

### Python 문제

> 예제1) 빈칸에 적합한 것

```python
x = 20

if x == 10 :
    print('10')
(  ) x == 20 :
    print('20')
else :
    print('other')

# 실행결과 20

# 정답: elif
```

### JAVA 문제

> 예제1) 실행 결과

```java
public class Rarr {
    static int[] marr() {
        int temp[] = new int[4];
        for (int i = 0; i < temp.length; i++)
            temp[i] = i;
        return temp;
    }

    public static void main(String[] args) {
        int iarr[];
        iarr = marr();
        for (int = 0; i < iarr.length; i++)
            System.out.print(iarr[i] + " ");
    }
}

// 정답: 0 1 2 3
```

> 예제2) 실행 결과

```java
public class Ape{
    static void rs(char a[]) {
        for (int i = 0; i < a.length; i++)
            if (a[i] == 'B')
                a[i] = 'C';
            else if (i == a.length - 1)
                a[i] = a[i - 1];
            else
                a[i] = a[i + 1];
    }

    static void pca(char a[]) {
        for (int i = 0; i < a.length; i++)
            System.out.print(a[i]);
            System.out.println();
    }

    public static void main(String[] args) {
        char c[] = {'A', 'B', 'D', 'D', 'A', 'B', 'C'};
        rs(c);
        pca(c);
    }
}
```

|   i   | 결과            | 설명                     |
| :---: | :-------------- | :----------------------- |
|   0   | `B` B D D A B C | `A[0]`을 `A[1]`로 변경   |
|   1   | B `C` D D A B C | `B`를 `C`로 변경         |
|   2   | B C `D` D A B C | `A[2]`를 `A[3]`으로 변경 |
|   3   | B C D `A` A B C | `A[3]`를 `A[4]`로 변경   |
|   4   | B C D A `B` B C | `A[4]`를 `A[5]`로 변경   |
|   5   | B C D A B `C` C | `B`를 `C`로 변경         |
|   6   | B C D A B C `C` | `A[6]`을 `A[5]`로 변경   |
